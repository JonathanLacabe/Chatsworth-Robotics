#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.
motor leftBackMotor2 = motor(PORT2, ratio18_1, false);

motor rightBackMotor4 = motor(PORT4, ratio18_1, true);

controller Controller1 = controller(primary);
motor liftMotor5 = motor(PORT5, ratio36_1, true);

motor liftMotor10 = motor(PORT10, ratio36_1, false);

motor rightMotor6 = motor(PORT6, ratio18_1, true);

motor leftMiddleMotor7 = motor(PORT7, ratio18_1, false);

motor leftFrontMotor9 = motor(PORT9, ratio18_1, false);

motor rightFrontMotor20 = motor(PORT20, ratio18_1, true);




// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}



// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;

#pragma endregion VEXcode Generated Robot Configuration
//question the braking system

// ----------------------------------------------------------------------------
//                                                                            
//    Project: the best robot                                               
//    Author: jonathan was  here
//    Created: 12-11-2023, 
//    Most Recent Edit: 1-27-2024
//    Configuration:        
//                                                                            
// ----------------------------------------------------------------------------


//pivot buttons
// Include the V5 Library
#include "vex.h"

// Allows for easier use of the VEX Library
using namespace vex;

float DEADZONE = 15.0;

// Begin project code
void driveLat(double degree){
  //+ = forward while negative degrees move backwards.
  leftBackMotor2.spinFor(forward, degree, degrees, false);//this false is VERY cool because it avoids sequentialization
  leftMiddleMotor7.spinFor(forward, degree, degrees, false);
  leftFrontMotor9.spinFor(forward, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  rightFrontMotor20.spinFor(forward, degree, degrees);
}

void turnDrive(double degree){
  // if val +, move left. if val -, move right.
  leftBackMotor2.spinFor(reverse, degree, degrees, false);
  leftMiddleMotor7.spinFor(reverse, degree, degrees, false);
  leftFrontMotor9.spinFor(reverse, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  rightFrontMotor20.spinFor(forward, degree, degrees);
}

void moveArm(double degree){//this could easily be changed to spinToPosition using the encoder, 
//which would require doing some trial and error to figure out the positioning, would ask to ask sam about that
  //positive = down, negatives = up
  if(degree>0){
    liftMotor5.spinFor(reverse, degree,degrees);
    liftMotor10.spinFor(reverse, degree,degrees);
  } else if (degree<0){
    liftMotor5.spinFor(forward, degree,degrees);
    liftMotor10.spinFor(forward, degree,degrees);
  }
  
}

void driveSpeed(double speed){
  //0-100, and I'l burn out motors if always set to 100
  leftBackMotor2.setVelocity(speed, percent);
  leftMiddleMotor7.setVelocity(speed, percent);
  leftFrontMotor9.setVelocity(speed, percent);
  rightBackMotor4.setVelocity(speed, percent);
  rightMotor6.setVelocity(speed, percent);
  rightFrontMotor20.setVelocity(speed, percent);
}

void preAutonomous(void) {
  // actions to do when the program starts
  Brain.Screen.clearScreen();
  Brain.Screen.print("pre auton code");
  wait(1, seconds);
}

void autonomous(void) {
  Brain.Screen.clearScreen();
  Brain.Screen.print("autonomous code");

//READ THIS 1-9-2023
//FOR THE MATCHLOADING, the arm should be set all the way in the front and it would spin to position -145 (test) to fling the thing backward.

  liftMotor5.setPosition(0, degrees);
  liftMotor10.setPosition(0, degrees);
liftMotor5.setVelocity(68, percent);
  liftMotor10.setVelocity(68, percent);
  driveSpeed(90);

  wait(45, seconds);
  //#1 - Set the arm to position where it can hit the bar without going through.
  liftMotor5.spinToPosition(80, degrees, false);
  liftMotor10.spinToPosition(80, degrees, false);
  wait(0.6, seconds);
  //#2 - move way forward so that the robot could reach the end and push all of the triballs in.
  driveLat(300);
  //#3 - Wait slightly any time and then come all the way back, hopefully touching the back bar at the very end.
   wait(0.5, seconds);
  driveLat(-200);
  wait(0.25, seconds);
  turnDrive(30);
  wait(0.25, seconds);
  driveLat(400);
  wait(0.2, seconds);
  driveLat(-100);
  wait(0.25, seconds);
  turnDrive(-40);
  driveLat(400);
  wait(0.25, seconds);
  driveLat(-100);
  wait(0.25, seconds);
  turnDrive(-25);
  driveLat(400);
  wait(0.25, seconds);
  driveLat(-100);
  wait(0.25, seconds);
  turnDrive(-30);
  driveLat(400);
  wait(0.5, seconds);
  driveLat(-600);
  wait(0.2, seconds);
  driveLat(600);
  wait(0.2, seconds);
  driveLat(-1000);

  //#4 - Reset the robot arm to its initial position aso that human player can matchload.
  liftMotor5.spinToPosition(0, degrees, false);
  liftMotor10.spinToPosition(0, degrees, false);




    /*
  liftMotor5.setVelocity(68, percent);
  liftMotor10.setVelocity(68, percent);
  liftMotor5.spinToPosition(140, degrees, false);
  liftMotor10.spinToPosition(140, degrees, false);

  
    //#1 - Move forward with the triball matchloaded at an exact angle so that it lodges into the goal zone.
  driveSpeed(90);
  driveLat(918);//drive forward and hit thing into thing
  wait(0.2, seconds);
  //#2 - Move backward to avoid knocking out the triball when turning.
  driveSpeed(95);
  driveLat(-5);
  driveSpeed(100);
  driveLat(-105);//move backward

  turnDrive(-601);                                       //  -435 = 135 degrees left.  #3 - Turn 135 degrees to position itself to move infront of the match load zone.
  wait(0.1, seconds);

//#4 - Move forward and turn rightward at 85% speed to be directly in front of the match load zone.
  driveLat(285);
  driveSpeed(85);
  turnDrive(-275);//junior programmers edit here.
//#5 - The J.P.S.S.: At drive speed at 60%, drive forward enough to be touching the match load zone barrier.
  //junior programmer's spinny spinny
  driveSpeed(60);
  driveLat(228);
  wait(0.12, seconds);

  //#6 - Move arm downward within the match load zone at 40% velocity.
  wait(1, seconds);

  //SPINNY SPINNY//#7 - Swipe the triball to the left from the center to knock the triball out of the match load zone.
  driveSpeed(65);
  turnDrive(550);
  //#8 - Move the arm back into the original position (e.g. 0 degrees on the arm motor).
  liftMotor5.spinToPosition(0, degrees, false);
  liftMotor10.spinToPosition(0, degrees, false);//these values need to be changed because the arm isnt supposed to go all the way back up
  wait(0.8, seconds);

  //RUN AWAY SMOKEY//#9 - Turn every slightly to the left and drive a good distance forward, then turn a bit rightward to account for weird positioning, and push forward the final stretch.
  turnDrive(-2);
  wait(0.2, seconds);
  driveLat(958);
  wait(0.1, seconds);
    turnDrive(69);
  driveLat(348);// these values may change because robot can't go to other side of field/it WAS 909
wait(0.2, seconds);

  //#10 - whack 'em. Move down the arm to touch/hit the barrier at 60% speed.
liftMotor5.spinToPosition(154, degrees, false);
  liftMotor10.spinToPosition(159, degrees, false);


*/
}

void armControl(bool upIn, bool downIn){
 //if(upIn & /*motor.encoder.position > 0*/){}

//if down && motor.encoder.position <140{}
  if(upIn){///     && (liftMotor10.position(degrees) < 140.0) && (liftMotor5.position(degrees) < 140.0)
  //ToDo: this NEEDS TO BE CHANGED, THE ENCODER CODE CAN BE IMPROVED
  //for the encoder, these should be changed to be spinFor of
  //a specific variable distance:
  //int degree = //figure out degree based on auto
    //while degree< some numbrar{}
        printf("VEXcode");
        liftMotor5.spin(forward, 50, percent);
        liftMotor10.spin(forward, 50, percent);
      
    }else if(downIn){//while degree> smaller numbrar[]
    //I would believe
      liftMotor5.spin(reverse, 50, percent);
      liftMotor10.spin(reverse, 50, percent);
    }else{
      liftMotor5.stop(brakeType::hold);
      liftMotor10.stop(brakeType::hold);
    }

/*lift*/
    

}

void motorControl(float leftIn, float rightIn){

  //TO EDIT:[[[[]]]]
  /* drive*/
  //left drive
leftFrontMotor9.spin(forward, leftIn, percent);
    leftMiddleMotor7.spin(forward, leftIn, percent);
    leftBackMotor2.spin(forward, leftIn, percent);
    
    //right drive
    rightFrontMotor20.spin(forward, rightIn, percent);
    rightMotor6.spin(forward, rightIn, percent);
    rightBackMotor4.spin(forward, rightIn, percent);
}

//drivecontrol

void driveControl(float fwdIn, float turnIn) {
  Brain.Screen.clearScreen();
  // place driver control in this while loop, so it runs infinitely until something tells it to do someting else
  float fwdVal;
  float turnVal;
  if(fabs(fwdIn) > DEADZONE){
      fwdVal = fwdIn;
  }else{
      fwdVal = 0;
  }

  if(fabs(turnIn)> DEADZONE){
    turnVal = turnIn;
  }else{
    turnVal = 0;
  }
//left and right:
  motorControl(fwdVal+turnVal, fwdVal - turnVal);
}

void userControl() {

///code the left button, axis 3, to be the movement of the robot forward and backward
liftMotor5.setPosition(0, degrees);
liftMotor10.setPosition(0, degrees);
    
    while (true) {
    ///
    driveControl(Controller1.Axis3.position(), Controller1.Axis1.position());
    armControl(Controller1.ButtonR2.pressing(), Controller1.ButtonR1.pressing());

    //if doesn't work: test if Controller on itself will work
    //these were axis2, I am changing them to axis3 to see if that will make it arcade.



//to save resources
    wait(20, msec);
  }
}
//only 


int main() {
  // create competition instance
  competition Competition;
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(userControl);

  // Run the pre-autonomous function.
  preAutonomous();

  // Prevent main from exiting with an infinite loop.


  //motor.encoder set the arm angle to 0.

  while (true) {
    wait(100, msec);
  }
}
