{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor leftBackMotor2 = motor(PORT2, ratio18_1, false);\n\nmotor rightBackMotor4 = motor(PORT4, ratio18_1, true);\n\ncontroller Controller1 = controller(primary);\nmotor liftMotor5 = motor(PORT5, ratio36_1, true);\n\nmotor liftMotor10 = motor(PORT10, ratio36_1, false);\n\nmotor rightMotor6 = motor(PORT6, ratio18_1, true);\n\nmotor leftMiddleMotor7 = motor(PORT7, ratio18_1, false);\n\nmotor leftFrontMotor9 = motor(PORT9, ratio18_1, false);\n\nmotor rightFrontMotor20 = motor(PORT20, ratio18_1, true);\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n//question the braking system\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project: the best robot                                               \n//    Author: jonathan was  here\n//    Created: 12-11-2023, \n//    Most Recent Edit: 1-27-2024\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n\n//pivot buttons\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nfloat DEADZONE = 15.0;\n\n// Begin project code\nvoid driveLat(double degree){\n  //+ = forward while negative degrees move backwards.\n  leftBackMotor2.spinFor(forward, degree, degrees, false);//this false is VERY cool because it avoids sequentialization\n  leftMiddleMotor7.spinFor(forward, degree, degrees, false);\n  leftFrontMotor9.spinFor(forward, degree, degrees, false);\n  rightBackMotor4.spinFor(forward, degree, degrees, false);\n  rightMotor6.spinFor(forward, degree, degrees, false);\n  rightFrontMotor20.spinFor(forward, degree, degrees);\n}\n\nvoid turnDrive(double degree){\n  // if val +, move left. if val -, move right.\n  leftBackMotor2.spinFor(reverse, degree, degrees, false);\n  leftMiddleMotor7.spinFor(reverse, degree, degrees, false);\n  leftFrontMotor9.spinFor(reverse, degree, degrees, false);\n  rightBackMotor4.spinFor(forward, degree, degrees, false);\n  rightMotor6.spinFor(forward, degree, degrees, false);\n  rightFrontMotor20.spinFor(forward, degree, degrees);\n}\n\nvoid moveArm(double degree){//this could easily be changed to spinToPosition using the encoder, \n//which would require doing some trial and error to figure out the positioning, would ask to ask sam about that\n  //positive = down, negatives = up\n  if(degree>0){\n    liftMotor5.spinFor(reverse, degree,degrees);\n    liftMotor10.spinFor(reverse, degree,degrees);\n  } else if (degree<0){\n    liftMotor5.spinFor(forward, degree,degrees);\n    liftMotor10.spinFor(forward, degree,degrees);\n  }\n  \n}\n\nvoid driveSpeed(double speed){\n  //0-100, and I'l burn out motors if always set to 100\n  leftBackMotor2.setVelocity(speed, percent);\n  leftMiddleMotor7.setVelocity(speed, percent);\n  leftFrontMotor9.setVelocity(speed, percent);\n  rightBackMotor4.setVelocity(speed, percent);\n  rightMotor6.setVelocity(speed, percent);\n  rightFrontMotor20.setVelocity(speed, percent);\n}\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n}\n\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n\n//READ THIS 1-9-2023\n//FOR THE MATCHLOADING, the arm should be set all the way in the front and it would spin to position -145 (test) to fling the thing backward.\n\n  liftMotor5.setPosition(0, degrees);\n  liftMotor10.setPosition(0, degrees);\nliftMotor5.setVelocity(68, percent);\n  liftMotor10.setVelocity(68, percent);\n  driveSpeed(90);\n\n  wait(45, seconds);\n  //#1 - Set the arm to position where it can hit the bar without going through.\n  liftMotor5.spinToPosition(80, degrees, false);\n  liftMotor10.spinToPosition(80, degrees, false);\n  wait(0.6, seconds);\n  //#2 - move way forward so that the robot could reach the end and push all of the triballs in.\n  driveLat(300);\n  //#3 - Wait slightly any time and then come all the way back, hopefully touching the back bar at the very end.\n   wait(0.5, seconds);\n  driveLat(-200);\n  wait(0.25, seconds);\n  turnDrive(30);\n  wait(0.25, seconds);\n  driveLat(400);\n  wait(0.2, seconds);\n  driveLat(-100);\n  wait(0.25, seconds);\n  turnDrive(-40);\n  driveLat(400);\n  wait(0.25, seconds);\n  driveLat(-100);\n  wait(0.25, seconds);\n  turnDrive(-25);\n  driveLat(400);\n  wait(0.25, seconds);\n  driveLat(-100);\n  wait(0.25, seconds);\n  turnDrive(-30);\n  driveLat(400);\n  wait(0.5, seconds);\n  driveLat(-600);\n  wait(0.2, seconds);\n  driveLat(600);\n  wait(0.2, seconds);\n  driveLat(-1000);\n\n  //#4 - Reset the robot arm to its initial position aso that human player can matchload.\n  liftMotor5.spinToPosition(0, degrees, false);\n  liftMotor10.spinToPosition(0, degrees, false);\n\n\n\n\n    /*\n  liftMotor5.setVelocity(68, percent);\n  liftMotor10.setVelocity(68, percent);\n  liftMotor5.spinToPosition(140, degrees, false);\n  liftMotor10.spinToPosition(140, degrees, false);\n\n  \n    //#1 - Move forward with the triball matchloaded at an exact angle so that it lodges into the goal zone.\n  driveSpeed(90);\n  driveLat(918);//drive forward and hit thing into thing\n  wait(0.2, seconds);\n  //#2 - Move backward to avoid knocking out the triball when turning.\n  driveSpeed(95);\n  driveLat(-5);\n  driveSpeed(100);\n  driveLat(-105);//move backward\n\n  turnDrive(-601);                                       //  -435 = 135 degrees left.  #3 - Turn 135 degrees to position itself to move infront of the match load zone.\n  wait(0.1, seconds);\n\n//#4 - Move forward and turn rightward at 85% speed to be directly in front of the match load zone.\n  driveLat(285);\n  driveSpeed(85);\n  turnDrive(-275);//junior programmers edit here.\n//#5 - The J.P.S.S.: At drive speed at 60%, drive forward enough to be touching the match load zone barrier.\n  //junior programmer's spinny spinny\n  driveSpeed(60);\n  driveLat(228);\n  wait(0.12, seconds);\n\n  //#6 - Move arm downward within the match load zone at 40% velocity.\n  wait(1, seconds);\n\n  //SPINNY SPINNY//#7 - Swipe the triball to the left from the center to knock the triball out of the match load zone.\n  driveSpeed(65);\n  turnDrive(550);\n  //#8 - Move the arm back into the original position (e.g. 0 degrees on the arm motor).\n  liftMotor5.spinToPosition(0, degrees, false);\n  liftMotor10.spinToPosition(0, degrees, false);//these values need to be changed because the arm isnt supposed to go all the way back up\n  wait(0.8, seconds);\n\n  //RUN AWAY SMOKEY//#9 - Turn every slightly to the left and drive a good distance forward, then turn a bit rightward to account for weird positioning, and push forward the final stretch.\n  turnDrive(-2);\n  wait(0.2, seconds);\n  driveLat(958);\n  wait(0.1, seconds);\n    turnDrive(69);\n  driveLat(348);// these values may change because robot can't go to other side of field/it WAS 909\nwait(0.2, seconds);\n\n  //#10 - whack 'em. Move down the arm to touch/hit the barrier at 60% speed.\nliftMotor5.spinToPosition(154, degrees, false);\n  liftMotor10.spinToPosition(159, degrees, false);\n\n\n*/\n}\n\nvoid armControl(bool upIn, bool downIn){\n //if(upIn & /*motor.encoder.position > 0*/){}\n\n//if down && motor.encoder.position <140{}\n  if(upIn){///     && (liftMotor10.position(degrees) < 140.0) && (liftMotor5.position(degrees) < 140.0)\n  //ToDo: this NEEDS TO BE CHANGED, THE ENCODER CODE CAN BE IMPROVED\n  //for the encoder, these should be changed to be spinFor of\n  //a specific variable distance:\n  //int degree = //figure out degree based on auto\n    //while degree< some numbrar{}\n        printf(\"VEXcode\");\n        liftMotor5.spin(forward, 50, percent);\n        liftMotor10.spin(forward, 50, percent);\n      \n    }else if(downIn){//while degree> smaller numbrar[]\n    //I would believe\n      liftMotor5.spin(reverse, 50, percent);\n      liftMotor10.spin(reverse, 50, percent);\n    }else{\n      liftMotor5.stop(brakeType::hold);\n      liftMotor10.stop(brakeType::hold);\n    }\n\n/*lift*/\n    \n\n}\n\nvoid motorControl(float leftIn, float rightIn){\n\n  //TO EDIT:[[[[]]]]\n  /* drive*/\n  //left drive\nleftFrontMotor9.spin(forward, leftIn, percent);\n    leftMiddleMotor7.spin(forward, leftIn, percent);\n    leftBackMotor2.spin(forward, leftIn, percent);\n    \n    //right drive\n    rightFrontMotor20.spin(forward, rightIn, percent);\n    rightMotor6.spin(forward, rightIn, percent);\n    rightBackMotor4.spin(forward, rightIn, percent);\n}\n\n//drivecontrol\n\nvoid driveControl(float fwdIn, float turnIn) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop, so it runs infinitely until something tells it to do someting else\n  float fwdVal;\n  float turnVal;\n  if(fabs(fwdIn) > DEADZONE){\n      fwdVal = fwdIn;\n  }else{\n      fwdVal = 0;\n  }\n\n  if(fabs(turnIn)> DEADZONE){\n    turnVal = turnIn;\n  }else{\n    turnVal = 0;\n  }\n//left and right:\n  motorControl(fwdVal+turnVal, fwdVal - turnVal);\n}\n\nvoid userControl() {\n\n///code the left button, axis 3, to be the movement of the robot forward and backward\nliftMotor5.setPosition(0, degrees);\nliftMotor10.setPosition(0, degrees);\n    \n    while (true) {\n    ///\n    driveControl(Controller1.Axis3.position(), Controller1.Axis1.position());\n    armControl(Controller1.ButtonR2.pressing(), Controller1.ButtonR1.pressing());\n\n    //if doesn't work: test if Controller on itself will work\n    //these were axis2, I am changing them to axis3 to see if that will make it arcade.\n\n\n\n//to save resources\n    wait(20, msec);\n  }\n}\n//only \n\n\nint main() {\n  // create competition instance\n  competition Competition;\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n\n\n  //motor.encoder set the arm angle to 0.\n\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[2],"name":"leftBackMotor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"rightBackMotor4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[5],"name":"liftMotor5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[10],"name":"liftMotor10","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[6],"name":"rightMotor6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[7],"name":"leftMiddleMotor7","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"leftFrontMotor9","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[20],"name":"rightFrontMotor20","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22}],"slot":1,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}