{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor leftBackMotor2 = motor(PORT2, ratio18_1, false);\n\nmotor rightBackMotor4 = motor(PORT4, ratio18_1, true);\n\ncontroller Controller1 = controller(primary);\nmotor liftMotor5 = motor(PORT5, ratio36_1, true);\n\nmotor liftMotor10 = motor(PORT10, ratio36_1, false);\n\nmotor rightMotor6 = motor(PORT6, ratio18_1, true);\n\nmotor leftMiddleMotor7 = motor(PORT7, ratio18_1, false);\n\nmotor leftFrontMotor9 = motor(PORT9, ratio18_1, false);\n\nmotor rightFrontMotor20 = motor(PORT20, ratio18_1, true);\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n//question the braking system\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project: VEX V5 Template.                                               \n//    Author: Chatsworth Charter Robotics Team (read: JONATHAN LACABE. including the documentation)\n//    Created: 12-11-2023 \n//    Most Recent Edit: 2-17-2024\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n/*\n       db   8b           d8  88        88  \n      d88b  `8b         d8'  88        88  \n     d8'`8b  `8b       d8'   88        88  \n    d8'  `8b  `8b     d8'    88aaaaaaaa88  \n   d8YaaaaY8b  `8b   d8'     88\"\"\"\"\"\"\"\"88  \n  d8\"\"\"\"\"\"\"\"8b  `8b d8'      88        88  \n d8'        `8b  `888'       88        88  \nd8'          `8b  `8'        88        88  \n\n\nFAQ: \n\nWhat drive control does this program use?\nThis program uses tank drive control as per reccomendation of the team coach, Sam F.\n\nDoes this program utilize\n\n\nHow do I add/change motors? \nTo add a motor, click the motor icon in the right of the blue area below the taskbar (the leftmost\nicon). Here, you will be able to add different motors along with their specifications, such as gear\ncartridge and motor direction. If you wish to add a motor group, make sure the motors you choose are\nboth moving the same direction (both being left or right motors), especially if using tank control.\n\nNote: Generally, left motors will be set to \"Normal\", while right motors will be set to \"Reverse\". \n\nThe example motors seen in the functions and labled in the #pragma region were those used for the \nOmega robot at Chatsworth, so feel free to change them. The naming system of the motors in this \nprogram is done to relate each motor to its port number, making the code more legible from a \nhardware perspective. If the name were to change, every instance of this motor used in the code \nwould need to be edited to reflect the change.\n\n\n\n\n*/\n\n\n//pivot buttons\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nfloat DEADZONE = 15.0;//This variable is meant to account for what the joystick is released by the driver, leaving it slightly off-center. See the driveControl function for usage.\n\n// Begin project code\n\n//===AUTONOMOUS FUNCTIONS===:\n/*The four functions below, driveLat, turnDrive, moveArm, and driveSpeed, are primarily designed\n  to be used in the code for the 15-second autonomous(void) routine.\n  ~DO NOT GET DISCOURAGED WHEN THE ROBOT PERFORMS A SLIGHTLY ALTERED ROUTINE WITHOUT CHANGES TO THE CODE:~\n\n  It may occur that on testing changes made to the code the previous day, or even just changing the \n  battery, the autonomous routine of your robot will have changed slightly. This can be frustrating, \n  especially when the code seemed perfected. \n  This is occuring due to the brain\n*/\n\n\n//This function\n/*Parameter:\n    double degree\n    This takes in a value used to tell the motors how many degrees to move backwards or forward.\n    The number of degrees is not relavent to anything except for the brain's encoder.\n*/\nvoid driveLat(double degree){\n  //+ = forward while negative degrees move backwards.\n  /*The false arguments at the end of these lines are VERY cool, as they remove sequentialization.\n    When this argument is set to be true or left blank, the rest of the program will not run until\n    this line has completed. This allows mulltiple lines to run simultaneously, which is useful as\n    thes\n  */\n  leftBackMotor2.spinFor(forward, degree, degrees, false);\n  \n  leftMiddleMotor7.spinFor(forward, degree, degrees, false);\n  leftFrontMotor9.spinFor(forward, degree, degrees, false);\n  rightBackMotor4.spinFor(forward, degree, degrees, false);\n  rightMotor6.spinFor(forward, degree, degrees, false);\n  rightFrontMotor20.spinFor(forward, degree, degrees);\n}\n\nvoid turnDrive(double degree){\n  // if val +, move left. if val -, move right.\n  leftBackMotor2.spinFor(reverse, degree, degrees, false);\n  leftMiddleMotor7.spinFor(reverse, degree, degrees, false);\n  leftFrontMotor9.spinFor(reverse, degree, degrees, false);\n  rightBackMotor4.spinFor(forward, degree, degrees, false);\n  rightMotor6.spinFor(forward, degree, degrees, false);\n  rightFrontMotor20.spinFor(forward, degree, degrees);\n}\n\nvoid moveArm(double degree){//this could easily be changed to spinToPosition using the encoder, \n//which would require doing some trial and error to figure out the positioning, would ask to ask sam about that\n  //positive = down, negatives = up\n  if(degree>0){\n    liftMotor5.spinFor(reverse, degree,degrees);\n    liftMotor10.spinFor(reverse, degree,degrees);\n  } else if (degree<0){\n    liftMotor5.spinFor(forward, degree,degrees);\n    liftMotor10.spinFor(forward, degree,degrees);\n  }\n  \n}\n\nvoid driveSpeed(double speed){\n  //0-100, and I'l burn out motors if always set to 100\n  leftBackMotor2.setVelocity(speed, percent);\n  leftMiddleMotor7.setVelocity(speed, percent);\n  leftFrontMotor9.setVelocity(speed, percent);\n  rightBackMotor4.setVelocity(speed, percent);\n  rightMotor6.setVelocity(speed, percent);\n  rightFrontMotor20.setVelocity(speed, percent);\n}\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n}\n\n\n//IMPORTANT NOTE: When establishing an autonomous routine, make sure to enable\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n\n//READ THIS 1-9-2023\n//FOR THE MATCHLOADING, the arm should be set all the way in the front and it would spin to position -145 (test) to fling the thing backward.\n\nbool facingNormal = false;\nint firstTurn = -135;\nint moveBack = -10;\nint turnAround = -601;\nint moveToLoadZone = -279;//\nint spinAround = 600;\nint secondToLastTurn = -49;\nint finalTurn = 138;\nint lastRun = 561;\n\nif(facingNormal){\n  firstTurn = -135;\n  moveBack = -10;\n  turnAround = -601;\n  moveToLoadZone = -279;\n  spinAround = 600;\n  secondToLastTurn = 38;\n  finalTurn = 138;\n  lastRun = 561;\n}else{\n  firstTurn = -135;\n  moveBack = -30;\n  turnAround = 601;\n  moveToLoadZone = 286;\n  spinAround = -600;\n  secondToLastTurn = 35;\n  finalTurn = -105;\n  lastRun = 551;\n}\n\n  liftMotor5.setPosition(0, degrees);\n  liftMotor10.setPosition(0, degrees);\n    //#1 - Move forward with the triball matchloaded at an exact angle so that it lodges into the goal zone.\n  driveSpeed(90);\n  driveLat(963);//drive forward and hit thing into thing\n  wait(0.2, seconds);\n  //#2 - Move backward to avoid knocking out the triball when turning.\n  driveSpeed(95);\n  driveLat(moveBack);\n  driveSpeed(100);\n  driveLat(firstTurn);//move backward\n\n  turnDrive(turnAround);//  -435 = 135 degrees left.  #3 - Turn 135 degrees to position itself to move infront of the match load zone.\n  wait(0.1, seconds);\n\n//#4 - Move forward and turn rightward at 85% speed to be directly in front of the match load zone.\n  driveLat(263);\n  driveSpeed(85);\n  turnDrive(moveToLoadZone);//junior programmers edit here.\n//#5 - The J.P.S.S.: At drive speed at 60%, drive forward enough to be touching the match load zone barrier.\n  //junior programmer's spinny spinny\n  wait(0.15, seconds);\n  driveSpeed(60);\n  driveLat(265);\n  wait(0.12, seconds);\n\n  //#6 - Move arm downward within the match load zone at 40% velocity.\n  //ARM DOWN\n  liftMotor5.setVelocity(41, percent);\n  liftMotor10.setVelocity(41, percent);\n\n  liftMotor5.spinToPosition(131, degrees, false);//if becomes too little switch to 232\n  liftMotor10.spinToPosition(131, degrees, false);\n  wait(1, seconds);\n\n  //SPINNY SPINNY//#7 - Swipe the triball to the left from the center to knock the triball out of the match load zone.\n  driveSpeed(70);\n  turnDrive(spinAround);///SHOAIBS LOO KERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  //#8 - Move the arm back into the original position (e.g. 0 degrees on the arm motor).\n  liftMotor5.spinToPosition(0, degrees, false);\n  liftMotor10.spinToPosition(0, degrees, false);//these values need to be changed because the arm isnt supposed to go all the way back up\n  wait(0.8, seconds);\n\n  //RUN AWAY SMOKEY//#9 - Turn every slightly to the left and drive a good distance forward, then turn a bit rightward to account for weird positioning, and push forward the final stretch.\n  turnDrive(secondToLastTurn);\n  wait(0.2, seconds);//\n  driveLat(758);\n  wait(0.1, seconds);\n    turnDrive(finalTurn);\n  driveLat(lastRun);// these values may change because robot can't go to other side of field/it WAS 909\nwait(0.2, seconds);\n\n  //#10 - whack 'em. Move down the arm to touch/hit the barrier at 60% speed.\nliftMotor5.spinToPosition(102, degrees, false);\n  liftMotor10.spinToPosition(102, degrees, false);\n\n\n\n\n\n\n\n  /*\n  driveSpeed(60);\n  driveLat(335);\n  wait(0.12, seconds);\n  //GRAB\n  liftMotor5.setVelocity(40, percent);\n  liftMotor10.setVelocity(40, percent);\n  liftMotor5.spinToPosition(145, degrees, false);\n  liftMotor10.spinToPosition(145, degrees, false);\n  wait(1, seconds);\n  liftMotor5.spinToPosition(1, degrees, false);\n  liftMotor10.spinToPosition(1, degrees, false);\n  wait(0.5, seconds);\n*/\n//when see triball {\n//  hit tribal into goal;\n//}\n\n\n\n\n////ENCODER TEST CODE:\n/*\nliftMotor5.setPosition(0, degrees);\nliftMotor10.setPosition(0, degrees);\nprintf(\"liftMotor5: %f\", liftMotor5.position(degrees));\nprintf(\"liftMotor10: %f\", liftMotor10.position(degrees));\nprintf(\"---------\");\nliftMotor5.setVelocity(90,percent);\nliftMotor10.setVelocity(90,percent);\nwhile(liftMotor10.position(degrees) != 145.0){\nliftMotor5.spinToPosition(145, degrees);\nliftMotor10.spinToPosition(145, degrees);\nprintf(\"liftMotor5: %f\", liftMotor5.position(degrees));\nprintf(\"liftMotor10: %f\", liftMotor10.position(degrees));\n}\nprintf(\"Completed movement 1\");\nwait(2, seconds);\n\nliftMotor5.spinToPosition(0, degrees);\nliftMotor10.spinToPosition(0, degrees);\n\nwait(5, seconds);\nliftMotor5.setVelocity(80,percent);\nliftMotor10.setVelocity(80,percent);\n\nliftMotor5.spinToPosition(145, degrees);\nliftMotor10.spinToPosition(145, degrees);\nwait(2, seconds);\nliftMotor5.setVelocity(80,percent);\nliftMotor10.setVelocity(80,percent);\n\nliftMotor5.spinToPosition(0, degrees);\nliftMotor10.spinToPosition(0, degrees);\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n  //ALL THE ACTUAL AUTO CODE IS BELOW:\n  // place automonous code here\n\n  \n\n  //turn 90 degrees to the left, 85% speed \n//driveSpeed(85);\n//turnDrive(400);//guess at 90 degrees\n\n  //backup until get close to the barrier but not close enough that it will not be able to turn after this 90% speed\n//driveSpeed(90);\n//driveLat(-100);\n\n  //arm it: 100% speed\n//driveSpeed(100);\n//liftMotor5.setVelocity(100, percent);\n  //liftMotor10.setVelocity(100, percent);\n//moveArm(100);\n\n  //turn 45 degrees to the left (adjust on ability to move past that damn barrier thing). 90% speed\n//driveSpeed(90);\n\n  //move forward all the way to the match load zone 95% speed\n//driveSpeed(95);\n\n  //arm the arm all the way forward to capture the triball in there. 85% speed.\n  //driveSpeed(85);\n\n  //move the arm back up a good bit so that it will be able to touch the bar. see the optional for how this may change. 80% speed\n//driveSpeed(80);\n\n  //move forward a small amount, whatever amount is necessary to allow the robot to turn toward the upper bar. 70% speed\n //driveSpeed(70);\n\n  //turn right by 45 degrees (or further if that is what is needed to move past that bar) 95% speed\n//driveSpeed(95);\n\n  //bolt to the end. the arm should touch the bar 100% speed\n//driveSpeed(100);\n\n  //optional: if there is some rule against having the triball attached to the robot at the end of auto, then REALLY whack the arm against the bar at this point. 100% speed\n//driveSpeed(100);\n\n  //\n  \n  //\n  \n  //\n/*\n  liftMotor5.setVelocity(80, percent);\n  liftMotor10.setVelocity(80, percent);\nmoveArm(90);\n  //step2\ndriveSpeed(65);\ndriveLat(300);\n  //step 3\nliftMotor5.setVelocity(70,percent);\nliftMotor10.setVelocity(70,percent);\nmoveWing(-90);\n  //step 4\n  driveSpeed(75);\n  turnDrive(600);//because the degrees is always going to be wack - this is meant to go 135\n//step 5\ndriveSpeed(90);\ndriveLat(800);\n//step 6\nliftMotor5.setVelocity(80,percent);\nliftMotor10.setVelocity(80,percent);\nmoveWing(90);\n//step 7\ndriveSpeed(70);\nturnDrive(-400);\n*/\n}\n\nvoid armControl(bool upIn, bool downIn){\n //if(upIn & /*motor.encoder.position > 0*/){}\n\n//if down && motor.encoder.position <140{}\n  if(upIn){///     && (liftMotor10.position(degrees) < 140.0) && (liftMotor5.position(degrees) < 140.0)\n  //ToDo: this NEEDS TO BE CHANGED, THE ENCODER CODE CAN BE IMPROVED\n  //for the encoder, these should be changed to be spinFor of\n  //a specific variable distance:\n  //int degree = //figure out degree based on auto\n    //while degree< some numbrar{}\n        printf(\"VEXcode\");\n        liftMotor5.spin(forward, 50, percent);\n        liftMotor10.spin(forward, 50, percent);\n      \n    }else if(downIn){//while degree> smaller numbrar[]\n    //I would believe\n      liftMotor5.spin(reverse, 50, percent);\n      liftMotor10.spin(reverse, 50, percent);\n    }else{\n      liftMotor5.stop(brakeType::hold);\n      liftMotor10.stop(brakeType::hold);\n    }\n\n/*lift*/\n    \n\n}\n\nvoid motorControl(float leftIn, float rightIn){\n  /* drive*/\n  //left drive\nleftFrontMotor9.spin(forward, leftIn, percent);\n    leftMiddleMotor7.spin(forward, leftIn, percent);\n    leftBackMotor2.spin(forward, leftIn, percent);\n    \n    //right drive\n    rightFrontMotor20.spin(forward, rightIn, percent);\n    rightMotor6.spin(forward, rightIn, percent);\n    rightBackMotor4.spin(forward, rightIn, percent);\n}\n\n//drivecontrol\n\nvoid driveControl(float fwdIn, float turnIn) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop, so it runs infinitely until something tells it to do someting else\n  float fwdVal;\n  float turnVal;\n  if(fabs(fwdIn) > DEADZONE){\n      fwdVal = fwdIn;\n  }else{\n      fwdVal = 0;\n  }\n\n  if(fabs(turnIn)> DEADZONE){\n    turnVal = turnIn;\n  }else{\n    turnVal = 0;\n  }\n//left and right:\n  motorControl(fwdVal+turnVal, fwdVal - turnVal);\n}\n\nvoid userControl() {\n\n///code the left button, axis 3, to be the movement of the robot forward and backward\nliftMotor5.setPosition(0, degrees);\nliftMotor10.setPosition(0, degrees);\n    \n    while (true) {\n    ///\n    driveControl(Controller1.Axis3.position(), Controller1.Axis1.position());//The joysticks, which return a value from -100 to 100 depending on upward/downward positioning\n    armControl(Controller1.ButtonR2.pressing(), Controller1.ButtonR1.pressing());\n\n    //if doesn't work: test if Controller on itself will work\n    //these were axis2, I am changing them to axis3 to see if that will make it arcade.\n\n\n\n//to save resources\n    wait(20, msec);\n  }\n}\n//only \n\n\nint main() {\n  // create competition instance\n  competition Competition;\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n\n\n  //motor.encoder set the arm angle to 0.\n\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[2],"name":"leftBackMotor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"rightBackMotor4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[5],"name":"liftMotor5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[10],"name":"liftMotor10","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[6],"name":"rightMotor6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[7],"name":"leftMiddleMotor7","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[9],"name":"leftFrontMotor9","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[20],"name":"rightFrontMotor20","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}