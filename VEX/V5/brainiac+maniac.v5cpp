#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.
controller Controller1 = controller(primary);
motor leftBackMotor2 = motor(PORT2, ratio18_1, false);

motor rightBackMotor4 = motor(PORT4, ratio18_1, true);

motor rightMotor6 = motor(PORT6, ratio18_1, true);

motor rightFrontMotor20 = motor(PORT20, ratio18_1, true);

motor leftMiddleMotor7 = motor(PORT7, ratio18_1, false);

motor leftFrontMotor9 = motor(PORT9, ratio18_1, false);

motor liftMotor5 = motor(PORT5, ratio36_1, true);

motor liftMotor10 = motor(PORT10, ratio36_1, false);




// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}



// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;

#pragma endregion VEXcode Generated Robot Configuration
//question the braking system
// ----------------------------------------------------------------------------
//                                                                            
//    Project: VEX V5 Template.                                               
//    Author: Chatsworth Charter Robotics Team (read: JONATHAN LACABE. including the documentation)
//    Created: 12-11-2023 
//    Most Recent Edit: 4-30-2024 (further documentation, minor changes)
//    Configuration:        
//                                                                            
// ----------------------------------------------------------------------------


//DOCUMENTATION UNDER CONSTRUCTION AS OF 4-30-2024


/*
       db   8b           d8  88        88  
      d88b  `8b         d8'  88        88  
     d8'`8b  `8b       d8'   88        88  
    d8'  `8b  `8b     d8'    88aaaaaaaa88  
   d8YaaaaY8b  `8b   d8'     88""""""""88  
  d8""""""""8b  `8b d8'      88        88  
 d8'        `8b  `888'       88        88  
d8'          `8b  `8'        88        88  



/*IF YOU ARE IMPORTING THIS CODE FROM GITHUB: MAKE SURE TO ADD THE EIGHT MOTORS AND THE CONTROLLER
  IN THE DEVICES SCREEN AS DETAILED IN THE FAQ. ENSURE THE GENERATED ROBOT CONFIGURATION OF THE 
  DEVICES IS IDENTICAL TO THE ONE IN THE GITHUB FILE, AS COPY-PASTING ALONE WILL NOT ADD THE DEVICES
  INTO THE DEVICES SCREEN. 
  Unless you want to make your own version of the code with different motors and things, in which 
  case feel free to change/add whatever you want.
*/



/*
===FAQ===

What drive control does this program use?
This program uses tank drive control as per recommendation of the team coach, Sam F.

What motors does this program utilize?
Though utilizing no motor groups (though it may in the future, specifically for the lift motors),
this program has six wheel motors, three right and three left motors, and two motors for the arm.
The wheel motors use green cartridges, while the arm motors use red cartridges.
The Chatsworth Robotics Vex robot is unique in that it has two arm motors, allowing the arm to be 
held in place, useful when grabbing a triball or other actions requiring exact positioning. 

Why aren't the motor encoders used to prevent the arm from hitting the ground?
This was an initial task that was worked on for some weeks, with some untested code having already 
been written (the comments visible in older commits). Once it was discovered that the ability of 
the robot to lift itself off of the ground using the arm was useful for a variety of purposes, we 
shelved this plan. The idea may be revisited in future robots/designs, however.
Because the motor encoder is not used, the arm can push the robot upward from the ground or from the 
elevation bar (in the game Over Under) to achieve an elevated position.

How do I add/change devices (motors, motor groups, controllers)? 
To add a motor, click the motor icon in the right of the blue area below the taskbar (the leftmost
icon) to access the devices screen. Here, you will be able to add different motors along with their 
specifications, such as gear cartridge and motor direction. If you wish to add a motor group, make 
sure the motors you choose are both moving the same direction (both being left or right motors), 
especially if using tank control.

Note: Generally, left motors will be set to "Normal", while right motors will be set to "Reverse". 

The example motors seen in the functions and labled in the #pragma region were those used for the 
Omega robot at Chatsworth, so feel free to change them. The naming system of the motors in this 
program is done to relate each motor to its port number, making the code more legible from a 
hardware perspective. If the name were to change, every instance of this motor used in the code 
would need to be edited to reflect the change.

Does this program utilize




*/


//pivot buttons
// Include the V5 Library
#include "vex.h"

// Allows for easier use of the VEX Library
using namespace vex;

/*This variable is meant to account for what the joystick is released by the driver, leaving it 
  slightly off-center. See the driveControl function for usage.*/
float DEADZONE = 15.0;

// Begin project code




//===AUTONOMOUS FUNCTIONS===
/*The four functions below, driveLat, turnDrive, moveArm, and driveSpeed, are primarily designed
  to be used in the code for the 15-second autonomous(void) routine.
  */

//driveLat(double degree)
//This function moves the robot forward or backward.

/*Parameter:
    double degree
    This takes in a value used to tell the motors how many degrees to move backward or forward.
    The number of degrees is not relevant to anything except for the brain's encoder.
    A positive value will move the robot forward, while negative degrees will move the robot
    backwards.
*/
void driveLat(double degree){
  /*The false arguments at the end of these lines are VERY cool, as they remove sequentialization.
    When this argument is set to be true or left blank, the rest of the program will not run until
    this line has completed. The false statement allows mulltiple lines to run simultaneously, 
    which is useful as this function is designed to move all of the wheel motors to move in one 
    direction.
    These lines are present in the driveLat and turnDrive functions, the only ones that set the
    position of the wheel motors. The moveArm function has similar arguments and setup, except it 
    uses the built-in motor encoder and the spinToPosition function.
  */
  leftBackMotor2.spinFor(forward, degree, degrees, false);
  leftMiddleMotor7.spinFor(forward, degree, degrees, false);
  leftFrontMotor9.spinFor(forward, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  /*The final line of each of the four functions does not have the ending false argument, as it
    will cause the program to actually run the code instead of skipping over everything. If the
    argument is set to false, then none of the code called in the function will run when used 
    except for its final call, and will serve to disable any function using it.
  */
  rightFrontMotor20.spinFor(forward, degree, degrees);
}
0

//turnDrive(double degree)
//This function turns the robot in a given direction.

/*Parameter:
    double degree
    The 'degree' inputted by the user is used to tell the motors how many degrees to pivot the
    robot in place.
    The number of degrees is not relevant to anything except for the brain's encoder.
    A positive value will move the robot forward, while negative degrees will move the robot
    backwards.
*/
void turnDrive(double degree){
  leftBackMotor2.spinFor(reverse, degree, degrees, false);
  leftMiddleMotor7.spinFor(reverse, degree, degrees, false);
  leftFrontMotor9.spinFor(reverse, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  rightFrontMotor20.spinFor(forward, degree, degrees);
}


//moveArm(double degree)
//This function moves the arm up and down.

/*Parameter:
    double degree
    The 'degree' inputted by the user determines how far the arm motors move upward or downward.
    The arm motor uses the red cartridge, while the wheel motors use green cartridges. Apart from 
    that, the arm motors are identical to the wheel motors, one being reverse and the other normal.
    The number of degrees is not relevant to anything except for the brain's encoder. Note that 
    this is the only function that uses the encoder to base movements off of the initial, user-set 
    position of the motors, as elaborated on within the function.
    A positive value will move the arm downward, while negative degrees will move the arm upward.
*/
void moveArm(double degree){
  /*The liftMotors are moved into the given position using the spinToPosition function. This is using
    the built in encoder of the motor, which can recall the initial position of the motor when the 
    code was first activated, further detailed in the setPosition function call in the autonomous 
    function. An alternate version of this function with the spinFor function, which does not use 
    the encoder, can be found in the VEX Template.
  */
  //The false argument below is done for the same purposes as the moveLat and turnDrive functions.
  liftMotor5.spinToPosition(degree, degrees, false);
  liftMotor10.spinToPosition(degree, degrees);
  
}

//driveSpeed(double speed)
//This function sets the velocity of the arm motors or arm motors to be a specific speed.

/*Parameters:
    double speed
    The 'speed' inputted by the user is indicative of a percentage of the maximum possible 
    speed the motors can move. The motors cannot move over 100%, and running the motors 
    at 100% constantly will burn them out very quickly. Only for very brief periods in the
    autonomous code are any motors set to 100% velocity.
    Any below 10% will produce a very slow autonomous.

    std::string type
    The 'type' of speed changed inputted by the user determines which motors are going to 
    be set to the velocity 'speed', preventing different groups of motors from all being
    changed to a new velocity where changes are not needed, such as a change in the speed
    of the arm motors resulting in the wheel motors changing speed as well.
*/

//TODO: CHANGE FUNCTION TO HAVE AN ADDITIONAL PARAMETER FOR TYPE, AND A CONDITIONAL TO ALLOW IT TO BE USED FOR 
//ARM MOTORS AS WELL. CHANGE AUTONOMOUS TO REFLECT THIS.[[[[]]]]
void driveSpeed(double speed, std::string type){
  if(type=="drive"){
    leftBackMotor2.setVelocity(speed, percent);
    leftMiddleMotor7.setVelocity(speed, percent);
    leftFrontMotor9.setVelocity(speed, percent);
    rightBackMotor4.setVelocity(speed, percent);
    rightMotor6.setVelocity(speed, percent);
    rightFrontMotor20.setVelocity(speed, percent);
  }else if(type=="lift"){
    liftMotor5.setVelocity(speed, percent);
    liftMotor10.setVelocity(speed, percent);
    /*If this function is ever called for something other than "drive" or "lift" (or for 
    other strings which can be added in the future), then everything that can possibly be
    done to alert the driver of a malfunction in the program, short of stopping the code
    altogether, must be done, as seen below:
    */
  }else{
  /*Sets the brain to show as bright red. If visible to the driver, this should immediately
    be cause for concern.*/
    Brain.Screen.setFillColor(red);
    /*A pulse Controller Rumble, additionally alerting the driver of the error if the brain 
    of the robot is out of sight.*/
    Controller.rumble("-.-.");
    /*The for loop below will cause each of the lines within it to be ran 10 times, filling
    the red brain interface with error messages.*/
    for(int x =0; x<10; x++){
      Brain.Screen.print("Error: The driveSpeed function was called improperly.");
      printf("Error: The driveSpeed function was called improperly.");
    }
    
  }
  
}

void preAutonomous(void) {
  //Actions performed when the program starts.
  Brain.Screen.clearScreen();
  Brain.Screen.print("pre auton code");
  wait(1, seconds);
}


/*IMPORTANT NOTE: When establishing an autonomous routine, make sure to create an exact, replicatable
  initial position for the robot to start the routine. It is advised to use tools and other on-hand
  pieces to create a consistent placement for the robot and other field objects.
*/
void autonomous(void) {/*NOTE: This is the autonomous for the specific Chatsworth Robotics Vex V5 robot.
                         This can be used as the basis for another autonomus program, but for a clean
                         template for such purposes, see the VEX Template in the VEX folder.*/
/*
  ~DO NOT GET DISCOURAGED WHEN THE ROBOT PERFORMS SLIGHTLY DIFFERENT ROUTINES WITHOUT CHANGES TO THE CODE:~

  It may occur that on testing changes made to the code the previous day, or even just changing the 
  battery, the autonomous routine of your robot will have changed slightly. This can be frustrating, 
  especially when the code seemed perfected. 
  This is occuring because the brain has a mind of its own (pun intended), as the internal counters
  and everything fluctuate due to a variety of factors, such as temperature and battery power. Thus,
  as the power of the battery decreases, any precise autonomous routine will begin to run at a lower
  performance with increased error. 
  
  BEFORE CHANGING YOUR CODE, TEST THE ROBOT AT FULL BATTERY. The brain and internal counters will be
  at optimal performance. If the errors and irregularities continue, approach hanging the code with
  caution, and always take backups of the last known functional version to revert to if needs be.
  
  Slight differences in the positioning of the robot, as noted in the important note above the header, 
  can easily result in slight errors snowballing into a non-functional routine. Always ensure a 
  consistent robot placement and matchfield.
*/
  Brain.Screen.clearScreen();
  Brain.Screen.print("autonomous code");

/*FINAL NOTE: Don't be afraid to use trial and error! The best programs are always created through
  rigorous testing and patching 999999999 errors/slight inconsistencies. Believe in yourself :3
*/  

//READ THIS 1-9-2023
//FOR THE MATCHLOADING, the arm should be set all the way in the front and it would spin to position -145 (test) to fling the thing backward.


bool facingNormal = false;
int firstTurn = -135;
int moveBack = -10;
int turnAround = -601;
int moveToLoadZone = -279;//
int spinAround = 600;
int secondToLastTurn = -49;
int finalTurn = 138;
int lastRun = 561;

if(facingNormal){
  firstTurn = -135;
  moveBack = -10;
  turnAround = -601;
  moveToLoadZone = -279;
  spinAround = 600;
  secondToLastTurn = 38;
  finalTurn = 138;
  lastRun = 561;
}else{
  firstTurn = -135;
  moveBack = -30;
  turnAround = 601;
  moveToLoadZone = 286;
  spinAround = -600;
  secondToLastTurn = 35;
  finalTurn = -105;
  lastRun = 551;
}
  /*In order to faciliate matchloading, and to make the rest of the code moving the arm function
    (such as the AWP, obtained by touching the horizontal elevation bar with the arm at the end of 
    the routine), the built-in motor encoder is utilized to make the program remember the initial 
    position of the liftMotors, e.g. the position that the arm is moved to before autonomous is
    started. Because of this, it is imperative that the arm is always moved into the same position 
    before starting, and that all of the code is based off of this initial position. This same
    logic can be used in an algorithm used for preventing the robot arm from touching the ground,
    as noted in the FAQ.
    As the first position of the arm (which, for the Chatsworth Vex V5 Omega robot, entails pushing
    the arm as far backward as possible) is the base position for all other positions, this 
    position is rendered as zero in the code.
  */
  liftMotor5.setPosition(0, degrees);
  liftMotor10.setPosition(0, degrees);


    //#1 - Move forward with the triball matchloaded at an exact angle so that it lodges into the goal zone.
  driveSpeed(90, "drive");
  driveLat(963);//drive forward and hit thing into thing
  wait(0.2, seconds);
  //#2 - Move backward to avoid knocking out the triball when turning.
  driveSpeed(95, "drive");
  driveLat(moveBack);
  driveSpeed(100, "drive");
  driveLat(firstTurn);//move backward

  turnDrive(turnAround);//  -435 = 135 degrees left.  #3 - Turn 135 degrees to position itself to move infront of the match load zone.
  wait(0.1, seconds);

//#4 - Move forward and turn rightward at 85% speed to be directly in front of the match load zone.
  driveLat(263);
  driveSpeed(85, "drive");
  turnDrive(moveToLoadZone);//junior programmers edit here.
//#5 - The J.P.S.S.: At drive speed at 60%, drive forward enough to be touching the match load zone barrier.
  //junior programmer's spinny spinny
  wait(0.15, seconds);
  driveSpeed(60, "drive");
  driveLat(265);
  wait(0.12, seconds);

  //#6 - Move arm downward within the match load zone at 40% velocity.
  //ARM DOWN
  driveSpeed(41, "lift");

  moveArm(131);//if becomes too little switch to 232
  wait(1, seconds);

  //SPINNY SPINNY//#7 - Swipe the triball to the left from the center to knock the triball out of the match load zone.
  driveSpeed(70, "drive");
  turnDrive(spinAround);
  //#8 - Move the arm back into the original position (e.g. 0 degrees on the arm motor).
  moveArm(0);//these values need to be changed because the arm isnt supposed to go all the way back up
  wait(0.8, seconds);

  //RUN AWAY SMOKEY//#9 - Turn every slightly to the left and drive a good distance forward, then turn a bit rightward to account for weird positioning, and push forward the final stretch.
  turnDrive(secondToLastTurn);
  wait(0.2, seconds);//
  driveLat(758);
  wait(0.1, seconds);
    turnDrive(finalTurn);
  driveLat(lastRun);// these values may change because robot can't go to other side of field/it WAS 909
wait(0.2, seconds);

  //#10 - whack 'em. Move down the arm to touch/hit the barrier at 60% speed.
  moveArm(102);

}

void armControl(bool upIn, bool downIn){
 //if(upIn & /*motor.encoder.position > 0*/){}

//if down && motor.encoder.position <140{}
  if(upIn){///     && (liftMotor10.position(degrees) < 140.0) && (liftMotor5.position(degrees) < 140.0)
  //ToDo: this NEEDS TO BE CHANGED, THE ENCODER CODE CAN BE IMPROVED
  //for the encoder, these should be changed to be spinFor of
  //a specific variable distance:
  //int degree = //figure out degree based on auto
    //while degree< some numbrar{}
        printf("VEXcode");
        liftMotor5.spin(forward, 50, percent);
        liftMotor10.spin(forward, 50, percent);
      
    }else if(downIn){//while degree> smaller numbrar[]
    //I would believe
      liftMotor5.spin(reverse, 50, percent);
      liftMotor10.spin(reverse, 50, percent);
    }else{
      liftMotor5.stop(brakeType::hold);
      liftMotor10.stop(brakeType::hold);
    }

/*lift*/
    

}

void motorControl(float leftIn, float rightIn){
  /* drive*/
  //left drive
leftFrontMotor9.spin(forward, leftIn, percent);
    leftMiddleMotor7.spin(forward, leftIn, percent);
    leftBackMotor2.spin(forward, leftIn, percent);
    
    //right drive
    rightFrontMotor20.spin(forward, rightIn, percent);
    rightMotor6.spin(forward, rightIn, percent);
    rightBackMotor4.spin(forward, rightIn, percent);
}

//drivecontrol

void driveControl(float fwdIn, float turnIn) {
  Brain.Screen.clearScreen();
  // place driver control in this while loop, so it runs infinitely until something tells it to do someting else
  float fwdVal;
  float turnVal;
  if(fabs(fwdIn) > DEADZONE){
      fwdVal = fwdIn;
  }else{
      fwdVal = 0;
  }

  if(fabs(turnIn)> DEADZONE){
    turnVal = turnIn;
  }else{
    turnVal = 0;
  }
//left and right:
  motorControl(fwdVal+turnVal, fwdVal - turnVal);
}

void userControl() {

///code the left button, axis 3, to be the movement of the robot forward and backward
liftMotor5.setPosition(0, degrees);
liftMotor10.setPosition(0, degrees);
    
    while (true) {
    ///
    driveControl(Controller1.Axis3.position(), Controller1.Axis1.position());//The joysticks, which return a value from -100 to 100 depending on upward/downward positioning
    armControl(Controller1.ButtonR2.pressing(), Controller1.ButtonR1.pressing());

    //if doesn't work: test if Controller on itself will work
    //these were axis2, I am changing them to axis3 to see if that will make it arcade.

    wait(20, msec);//Done to save resources.
  }
}
//only 


int main() {
  // create competition instance
  competition Competition;
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(userControl);

  // Run the pre-autonomous function.
  preAutonomous();

  // Prevent main from exiting with an infinite loop.


  //motor.encoder set the arm angle to 0.

  while (true) {
    wait(100, msec);
  }
}
