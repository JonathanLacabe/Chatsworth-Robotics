#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.
controller Controller1 = controller(primary);
motor leftBackMotor2 = motor(PORT2, ratio18_1, false);

motor rightBackMotor4 = motor(PORT4, ratio18_1, true);

motor rightMotor6 = motor(PORT6, ratio18_1, true);

motor rightFrontMotor20 = motor(PORT20, ratio18_1, true);

motor leftMiddleMotor7 = motor(PORT7, ratio18_1, false);

motor leftFrontMotor9 = motor(PORT9, ratio18_1, false);

motor liftMotor5 = motor(PORT5, ratio36_1, true);

motor liftMotor10 = motor(PORT10, ratio36_1, false);




// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}



// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;

#pragma endregion VEXcode Generated Robot Configuration
//question the braking system
// ----------------------------------------------------------------------------
//                                                                            
//    Project: VEX V5 Template.                                               
//    Author: Chatsworth Charter Robotics Team (read: JONATHAN LACABE. including the documentation)
//    Created: 12-11-2023 
//    Most Recent Edit: 2-17-2024
//    Configuration:        
//                                                                            
// ----------------------------------------------------------------------------


//DOCUMENTATION UNDER CONSTRUCTION AS OF 4-29-2024


/*
       db   8b           d8  88        88  
      d88b  `8b         d8'  88        88  
     d8'`8b  `8b       d8'   88        88  
    d8'  `8b  `8b     d8'    88aaaaaaaa88  
   d8YaaaaY8b  `8b   d8'     88""""""""88  
  d8""""""""8b  `8b d8'      88        88  
 d8'        `8b  `888'       88        88  
d8'          `8b  `8'        88        88  



/*IF YOU ARE IMPORTING THIS CODE FROM GITHUB: MAKE SURE TO ADD THE EIGHT MOTORS AND THE CONTROLLER
  IN THE DEVICES SCREEN AS DETAILED IN THE FAQ. ENSURE THE GENERATED ROBOT CONFIGURATION OF THE 
  DEVICES IS IDENTICAL TO THE ONE IN THE GITHUB FILE, AS COPY-PASTING ALONE WILL NOT ADD THE DEVICES
  INTO THE DEVICES SCREEN. 
  Unless you want to make your own version of the code with different motors and things, in which 
  case feel free to change/add whatever you want.
*/



/*
===FAQ===

What drive control does this program use?
This program uses tank drive control as per recommendation of the team coach, Sam F.

Does this program utilize

What motors does this program utilize?
Though utilizing no motor groups (though it may in the future, specifically for the lift motors),
this program has six wheel motors, three right and three left motors, and two motors for the arm.
The wheel motors use green cartridges, while the arm motors use red cartridges.
The Chatsworth Robotics Vex robot is unique in that it has two arm motors, allowing the arm to be 
held in place when grabbing a triball and to propel itself upward from the ground or from the 
elevation bar (in Over Under) to achieve an elevated position.

How do I add/change devices (motors, motor groups, controllers)? 
To add a motor, click the motor icon in the right of the blue area below the taskbar (the leftmost
icon) to access the devices screen. Here, you will be able to add different motors along with their 
specifications, such as gear cartridge and motor direction. If you wish to add a motor group, make 
sure the motors you choose are both moving the same direction (both being left or right motors), 
especially if using tank control.

Note: Generally, left motors will be set to "Normal", while right motors will be set to "Reverse". 

The example motors seen in the functions and labled in the #pragma region were those used for the 
Omega robot at Chatsworth, so feel free to change them. The naming system of the motors in this 
program is done to relate each motor to its port number, making the code more legible from a 
hardware perspective. If the name were to change, every instance of this motor used in the code 
would need to be edited to reflect the change.



*/


//pivot buttons
// Include the V5 Library
#include "vex.h"

// Allows for easier use of the VEX Library
using namespace vex;

/*This variable is meant to account for what the joystick is released by the driver, leaving it 
  slightly off-center. See the driveControl function for usage.*/
float DEADZONE = 15.0;

// Begin project code




//===AUTONOMOUS FUNCTIONS===
/*The four functions below, driveLat, turnDrive, moveArm, and driveSpeed, are primarily designed
  to be used in the code for the 15-second autonomous(void) routine.
  */

//driveLat(double degree)
//This function moves the robot forward or backward.

/*Parameter:
    double degree
    This takes in a value used to tell the motors how many degrees to move backward or forward.
    The number of degrees is not relevant to anything except for the brain's encoder.
    A positive value will move the robot forward, while negative degrees will move the robot
    backwards.
*/
void driveLat(double degree){
  /*The false arguments at the end of these lines are VERY cool, as they remove sequentialization.
    When this argument is set to be true or left blank, the rest of the program will not run until
    this line has completed. The false statement allows mulltiple lines to run simultaneously, 
    which is useful as this function is designed to move all of the wheel motors to move in one 
    direction.
    These lines are present in the driveLat and turnDrive functions, the only ones that set the
    position of the wheel motors. The moveArm function has similar arguments and setup, except it 
    uses the built-in motor encoder and the spinToPosition function.
  */
  leftBackMotor2.spinFor(forward, degree, degrees, false);
  leftMiddleMotor7.spinFor(forward, degree, degrees, false);
  leftFrontMotor9.spinFor(forward, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  /*The final line of each of the four functions does not have the ending false argument, as it
    will cause the program to actually run the code instead of skipping over everything. If the
    argument is set to false, then none of the code called in the function will run when used 
    except for its final call, and will serve to disable any function using it.
  */
  rightFrontMotor20.spinFor(forward, degree, degrees);
}


//turnDrive(double degree)
//This function turns the robot in a given direction.

/*Parameter:
    double degree
    The 'degree' inputted by the user is used to tell the motors how many degrees to pivot the
    robot in place.
    The number of degrees is not relevant to anything except for the brain's encoder.
    A positive value will move the robot forward, while negative degrees will move the robot
    backwards.
*/
void turnDrive(double degree){
  leftBackMotor2.spinFor(reverse, degree, degrees, false);
  leftMiddleMotor7.spinFor(reverse, degree, degrees, false);
  leftFrontMotor9.spinFor(reverse, degree, degrees, false);
  rightBackMotor4.spinFor(forward, degree, degrees, false);
  rightMotor6.spinFor(forward, degree, degrees, false);
  rightFrontMotor20.spinFor(forward, degree, degrees);
}


//moveArm(double degree)
//This function moves the arm up and down.

/*Parameter:
    double degree
    The 'degree' inputted by the user determines how far the arm motors move upward or downward.
    The arm motor uses the red cartridge, while the wheel motors use green cartridges. Apart from 
    that, the arm motors are identical to the wheel motors, one being reverse and the other normal.
    The number of degrees is not relevant to anything except for the brain's encoder.
    A positive value will move the arm downward, while negative degrees will move the arm upward.
*/
void moveArm(double degree){
  /*The liftMotors are moved into the given position using the spinToPosition function. This is using
    the built in encoder of the motor, which can recall the initial position of the motor when it was
    first activated, further detailed in the setPosition function call in the autonomous function.
    An alternate version of this function with the spinFor function, which does not use the encoder, 
    can be found in the VEX Template.
  */
  //The false argument below is done for the same purposes as the moveLat and turnDrive functions.
  liftMotor5.spinToPosition(degree, degrees, false);
  liftMotor10.spinToPosition(degree, degrees);
  
}

void driveSpeed(double speed){
  //0-100, and I'l burn out motors if always set to 100
  leftBackMotor2.setVelocity(speed, percent);
  leftMiddleMotor7.setVelocity(speed, percent);
  leftFrontMotor9.setVelocity(speed, percent);
  rightBackMotor4.setVelocity(speed, percent);
  rightMotor6.setVelocity(speed, percent);
  rightFrontMotor20.setVelocity(speed, percent);
}

void preAutonomous(void) {
  // actions to do when the program starts
  Brain.Screen.clearScreen();
  Brain.Screen.print("pre auton code");
  wait(1, seconds);
}


/*IMPORTANT NOTE: When establishing an autonomous routine, make sure to create an exact, replicatable
  initial position for the robot to start the routine. It is advised to use tools and other on-hand
  pieces to create a consistent placement for the robot and other field objects.
*/
void autonomous(void) {/*NOTE: This is the autonomous for the specific Chatsworth Robotics Vex V5 robot.
                         This can be used as the basis for another autonomus program, but for a clean
                         template for such purposes, see the VEX Template in the VEX folder.*/
/*
  ~DO NOT GET DISCOURAGED WHEN THE ROBOT PERFORMS SLIGHTLY DIFFERENT ROUTINES WITHOUT CHANGES TO THE CODE:~

  It may occur that on testing changes made to the code the previous day, or even just changing the 
  battery, the autonomous routine of your robot will have changed slightly. This can be frustrating, 
  especially when the code seemed perfected. 
  This is occuring because the brain has a mind of its own (pun intended), as the internal counters
  and everything fluctuate due to a variety of factors, such as temperature and battery power. Thus,
  as the power of the battery decreases, any precise autonomous routine will begin to run at a lower
  performance with increased error. It is always advised to make changes to the code and to test it
  at full battery, when the the robot and the internal counters will be at optimal performance.
  
  Slight differences in the positioning of the robot, as noted in the important note above the header, 
  can easily result in slight errors snowballing into a non-functional routine. Always ensure a 
  consistent placement and field.
*/
  Brain.Screen.clearScreen();
  Brain.Screen.print("autonomous code");

/*FINAL NOTE: Don't be afraid to use trial and error! The best programs are always created through
  rigorous testing and patching 999999999 errors/slight inconsistencies. Believe in yourself :3
*/  

//READ THIS 1-9-2023
//FOR THE MATCHLOADING, the arm should be set all the way in the front and it would spin to position -145 (test) to fling the thing backward.


bool facingNormal = false;
int firstTurn = -135;
int moveBack = -10;
int turnAround = -601;
int moveToLoadZone = -279;//
int spinAround = 600;
int secondToLastTurn = -49;
int finalTurn = 138;
int lastRun = 561;

if(facingNormal){
  firstTurn = -135;
  moveBack = -10;
  turnAround = -601;
  moveToLoadZone = -279;
  spinAround = 600;
  secondToLastTurn = 38;
  finalTurn = 138;
  lastRun = 561;
}else{
  firstTurn = -135;
  moveBack = -30;
  turnAround = 601;
  moveToLoadZone = 286;
  spinAround = -600;
  secondToLastTurn = 35;
  finalTurn = -105;
  lastRun = 551;
}

  liftMotor5.setPosition(0, degrees);//TO WRITE EXPLANATION FOR[[[[[[[[[[[4-29-2024]]]]]]]]]]]
  liftMotor10.setPosition(0, degrees);
    //#1 - Move forward with the triball matchloaded at an exact angle so that it lodges into the goal zone.
  driveSpeed(90);
  driveLat(963);//drive forward and hit thing into thing
  wait(0.2, seconds);
  //#2 - Move backward to avoid knocking out the triball when turning.
  driveSpeed(95);
  driveLat(moveBack);
  driveSpeed(100);
  driveLat(firstTurn);//move backward

  turnDrive(turnAround);//  -435 = 135 degrees left.  #3 - Turn 135 degrees to position itself to move infront of the match load zone.
  wait(0.1, seconds);

//#4 - Move forward and turn rightward at 85% speed to be directly in front of the match load zone.
  driveLat(263);
  driveSpeed(85);
  turnDrive(moveToLoadZone);//junior programmers edit here.
//#5 - The J.P.S.S.: At drive speed at 60%, drive forward enough to be touching the match load zone barrier.
  //junior programmer's spinny spinny
  wait(0.15, seconds);
  driveSpeed(60);
  driveLat(265);
  wait(0.12, seconds);

  //#6 - Move arm downward within the match load zone at 40% velocity.
  //ARM DOWN
  liftMotor5.setVelocity(41, percent);
  liftMotor10.setVelocity(41, percent);

  moveArm(131);//if becomes too little switch to 232
  wait(1, seconds);

  //SPINNY SPINNY//#7 - Swipe the triball to the left from the center to knock the triball out of the match load zone.
  driveSpeed(70);
  turnDrive(spinAround);
  //#8 - Move the arm back into the original position (e.g. 0 degrees on the arm motor).
  moveArm(0);//these values need to be changed because the arm isnt supposed to go all the way back up
  wait(0.8, seconds);

  //RUN AWAY SMOKEY//#9 - Turn every slightly to the left and drive a good distance forward, then turn a bit rightward to account for weird positioning, and push forward the final stretch.
  turnDrive(secondToLastTurn);
  wait(0.2, seconds);//
  driveLat(758);
  wait(0.1, seconds);
    turnDrive(finalTurn);
  driveLat(lastRun);// these values may change because robot can't go to other side of field/it WAS 909
wait(0.2, seconds);

  //#10 - whack 'em. Move down the arm to touch/hit the barrier at 60% speed.
  moveArm(102);

}

void armControl(bool upIn, bool downIn){
 //if(upIn & /*motor.encoder.position > 0*/){}

//if down && motor.encoder.position <140{}
  if(upIn){///     && (liftMotor10.position(degrees) < 140.0) && (liftMotor5.position(degrees) < 140.0)
  //ToDo: this NEEDS TO BE CHANGED, THE ENCODER CODE CAN BE IMPROVED
  //for the encoder, these should be changed to be spinFor of
  //a specific variable distance:
  //int degree = //figure out degree based on auto
    //while degree< some numbrar{}
        printf("VEXcode");
        liftMotor5.spin(forward, 50, percent);
        liftMotor10.spin(forward, 50, percent);
      
    }else if(downIn){//while degree> smaller numbrar[]
    //I would believe
      liftMotor5.spin(reverse, 50, percent);
      liftMotor10.spin(reverse, 50, percent);
    }else{
      liftMotor5.stop(brakeType::hold);
      liftMotor10.stop(brakeType::hold);
    }

/*lift*/
    

}

void motorControl(float leftIn, float rightIn){
  /* drive*/
  //left drive
leftFrontMotor9.spin(forward, leftIn, percent);
    leftMiddleMotor7.spin(forward, leftIn, percent);
    leftBackMotor2.spin(forward, leftIn, percent);
    
    //right drive
    rightFrontMotor20.spin(forward, rightIn, percent);
    rightMotor6.spin(forward, rightIn, percent);
    rightBackMotor4.spin(forward, rightIn, percent);
}

//drivecontrol

void driveControl(float fwdIn, float turnIn) {
  Brain.Screen.clearScreen();
  // place driver control in this while loop, so it runs infinitely until something tells it to do someting else
  float fwdVal;
  float turnVal;
  if(fabs(fwdIn) > DEADZONE){
      fwdVal = fwdIn;
  }else{
      fwdVal = 0;
  }

  if(fabs(turnIn)> DEADZONE){
    turnVal = turnIn;
  }else{
    turnVal = 0;
  }
//left and right:
  motorControl(fwdVal+turnVal, fwdVal - turnVal);
}

void userControl() {

///code the left button, axis 3, to be the movement of the robot forward and backward
liftMotor5.setPosition(0, degrees);
liftMotor10.setPosition(0, degrees);
    
    while (true) {
    ///
    driveControl(Controller1.Axis3.position(), Controller1.Axis1.position());//The joysticks, which return a value from -100 to 100 depending on upward/downward positioning
    armControl(Controller1.ButtonR2.pressing(), Controller1.ButtonR1.pressing());

    //if doesn't work: test if Controller on itself will work
    //these were axis2, I am changing them to axis3 to see if that will make it arcade.

    wait(20, msec);//Done to save resources.
  }
}
//only 


int main() {
  // create competition instance
  competition Competition;
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(userControl);

  // Run the pre-autonomous function.
  preAutonomous();

  // Prevent main from exiting with an infinite loop.


  //motor.encoder set the arm angle to 0.

  while (true) {
    wait(100, msec);
  }
}
